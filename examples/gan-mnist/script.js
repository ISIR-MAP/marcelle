/* eslint-disable import/extensions */
/* global marcelle, mostCore, tf */
import { displaySamples, displayTensor } from './visualization.js';
import { GanTrainer, plotGanTraining } from './training.js';
// import { GanTrainer, plotGanTraining } from './training_emulator.js';
import { loadModel, predict, generateNoise, downsampleCamera } from './generation.js';

// Create a GAN model trainer, that communicates with a Python training backend
const gan = new GanTrainer({ epochs: 30000 });

// --------------------------------
// TRAINING
// --------------------------------
const [plotLosses, plotAccuracy] = plotGanTraining(gan);

const trainingLauncher = marcelle.button({ text: 'Start Training' });
trainingLauncher.name = 'Training Launcher';
gan.$training
  .thru(mostCore.map((x) => x.status))
  .thru(mostCore.skipRepeats)
  .subscribe((x) => {
    if (['start', 'epoch'].includes(x)) {
      trainingLauncher.$text.set('Stop Training');
    } else {
      trainingLauncher.$text.set('Start Training');
    }
  });
trainingLauncher.$click.subscribe(() => {
  if (['start', 'epoch'].includes(gan.$training.value.status)) {
    gan.stop();
  } else {
    gan.train();
  }
});

// Display samples generated by the GAN along the training process
const samples = displaySamples(gan);

// --------------------------------
// GENERATION
// --------------------------------
const genButton = marcelle.button({ text: 'Generate an Image' });
const $imagesOneShot = genButton.$click.thru(generateNoise).thru(predict);

const w = marcelle.webcam({ width: 10, height: 10 });
const $webcamNoise = w.$images.thru(mostCore.filter(() => w.$ready.value)).thru(downsampleCamera);
const $imagesWebcam = $webcamNoise
  .thru(mostCore.map((input) => input.sub(tf.scalar(0.5).mul(tf.scalar(2))).reshape([1, 100])))
  .thru(predict);

const displayInput = displayTensor($webcamNoise, 'Input Noise');

const displayResult = displayTensor(
  $imagesOneShot.thru(mostCore.merge($imagesWebcam)),
  'Generated Image',
);

const modelSlider = marcelle.slider({
  step: 1,
  pips: true,
  pipstep: 1,
  formatter: (i) => {
    if (gan.$models.value[i]) {
      return `${gan.$models.value[i].split('generator_')[1].split('.h5')[0]}`;
    }
    return '0';
  },
});
modelSlider.name = 'Browse Model Training History (Ticks indicate the number of epochs)';
gan.$models.subscribe((x) => {
  modelSlider.$max.set(Math.max(1, x.length - 1));
});

const loadButton = marcelle.button({ text: 'Load Model' });
loadButton.name = 'Load model';
loadButton.$click.subscribe(async () => {
  loadButton.$loading.set(true);
  await loadModel(gan.$models.value[modelSlider.$values.value[0]]);
  loadButton.$loading.set(false);
});

const arrow = marcelle.text({
  text:
    '<div style="flex-grow: 1; align-self: center; text-align: center; font-size: 4rem;">â‡¨</div>',
});

const dashboard = marcelle.createDashboard({
  title: 'Marcelle Example - GAN for Image Generation (MNIST)',
  author: 'Marcelle Pirates Crew',
});

dashboard.page('Train').useLeft(marcelle.parameters(gan), trainingLauncher).use(
  marcelle.progress(gan),
  samples, // [plotLosses, plotAccuracy]
);
dashboard.page('Simple').use(modelSlider, [loadButton, genButton], displayResult);
dashboard
  .page('Webcam')
  .useLeft(w)
  .use(marcelle.text({ text: 'Love on the beat' }), modelSlider, loadButton, [
    displayInput,
    arrow,
    displayResult,
  ]);

dashboard.start();
